"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[58],{5318:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var a=n(7378);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=c(n),h=r,d=m["".concat(s,".").concat(h)]||m[h]||p[h]||l;return n?a.createElement(d,o(o({ref:t},u),{},{components:n})):a.createElement(d,o({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,o=new Array(l);o[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var c=2;c<l;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},517:function(e,t,n){n.d(t,{Z:function(){return r}});var a=n(7378);function r(e){var t=e.children,n=e.hidden,r=e.className;return a.createElement("div",{role:"tabpanel",hidden:n,className:r},t)}},637:function(e,t,n){n.d(t,{Z:function(){return u}});var a=n(5773),r=n(7378),l=n(6457),o=n(1429),i=n(8944),s="tabItem_WhCL";function c(e){var t,n,l,c=e.lazy,u=e.block,p=e.defaultValue,m=e.values,h=e.groupId,d=e.className,f=r.Children.map(e.children,(function(e){if((0,r.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),b=null!=m?m:f.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),g=(0,o.duplicates)(b,(function(e,t){return e.value===t.value}));if(g.length>0)throw new Error('Docusaurus error: Duplicate values "'+g.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var k=null===p?p:null!=(t=null!=p?p:null==(n=f.find((function(e){return e.props.default})))?void 0:n.props.value)?t:null==(l=f[0])?void 0:l.props.value;if(null!==k&&!b.some((function(e){return e.value===k})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+k+'" but none of its children has the corresponding value. Available values are: '+b.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var v=(0,o.useTabGroupChoice)(),y=v.tabGroupChoices,N=v.setTabGroupChoices,w=(0,r.useState)(k),C=w[0],x=w[1],T=[],M=(0,o.useScrollPositionBlocker)().blockElementScrollPositionUntilNextRender;if(null!=h){var j=y[h];null!=j&&j!==C&&b.some((function(e){return e.value===j}))&&x(j)}var O=function(e){var t=e.currentTarget,n=T.indexOf(t),a=b[n].value;a!==C&&(M(t),x(a),null!=h&&N(h,a))},P=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a=T.indexOf(e.currentTarget)+1;n=T[a]||T[0];break;case"ArrowLeft":var r=T.indexOf(e.currentTarget)-1;n=T[r]||T[T.length-1]}null==(t=n)||t.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":u},d)},b.map((function(e){var t=e.value,n=e.label,l=e.attributes;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:C===t?0:-1,"aria-selected":C===t,key:t,ref:function(e){return T.push(e)},onKeyDown:P,onFocus:O,onClick:O},l,{className:(0,i.Z)("tabs__item",s,null==l?void 0:l.className,{"tabs__item--active":C===t})}),null!=n?n:t)}))),c?(0,r.cloneElement)(f.filter((function(e){return e.props.value===C}))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},f.map((function(e,t){return(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==C})}))))}function u(e){var t=(0,l.Z)();return r.createElement(c,(0,a.Z)({key:String(t)},e))}},9486:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return u},default:function(){return f},frontMatter:function(){return c},metadata:function(){return p},toc:function(){return h}});var a=n(5773),r=n(808),l=(n(7378),n(5318)),o=n(637),i=n(517),s=["components"],c={title:"Matchers"},u=void 0,p={unversionedId:"matchers",id:"matchers",title:"Matchers",description:"Matchers are the backbone of Interweave as they allow arbitrary insertion of React elements into",source:"@site/docs/matchers.mdx",sourceDirName:".",slug:"/matchers",permalink:"/docs/matchers",editUrl:"https://github.com/milesj/interweave/edit/master/website/docs/matchers.mdx",tags:[],version:"current",frontMatter:{title:"Matchers"},sidebar:"docs",previous:{title:"Getting started",permalink:"/docs/"},next:{title:"Filters",permalink:"/docs/filters"}},m={},h=[{value:"Usage",id:"usage",level:2},{value:"Creating a matcher",id:"creating-a-matcher",level:2},{value:"Rendered elements",id:"rendered-elements",level:2},{value:"Greedy matching",id:"greedy-matching",level:2}],d={toc:h};function f(e){var t=e.components,n=(0,r.Z)(e,s);return(0,l.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"Matchers are the backbone of Interweave as they allow arbitrary insertion of React elements into\nstrings, through the use of regex pattern matching. This feature is quite powerful as it opens up\nmany possibilities."),(0,l.kt)("p",null,'It works by matching patterns within a string, deconstructing it into tokens, and reconstructing it\nback into an array of strings and React elements, therefore, permitting it to be rendered by React\'s\nvirtual DOM layer. For example, take the following string "Check out my website,\ngithub.com/milesj!", and a ',(0,l.kt)("inlineCode",{parentName:"p"},"UrlMatcher"),", you'd get the following array."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx"},"['Check out my website, ', <Url>github.com/milesj</Url>, '!'];\n")),(0,l.kt)("h2",{id:"usage"},"Usage"),(0,l.kt)("p",null,"Matchers can be passed to each render of ",(0,l.kt)("inlineCode",{parentName:"p"},"<Interweave />"),". When adding a matcher, a unique\ncamel-case name must be passed to the constructor."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx"},"<Interweave matchers={[new CustomMatcher('foo')]} />\n")),(0,l.kt)("p",null,"To disable all matchers, per render, pass the ",(0,l.kt)("inlineCode",{parentName:"p"},"disableMatchers")," prop."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx"},"<Interweave disableMatchers />\n")),(0,l.kt)("p",null,'To disable a single matcher, you can pass a prop that starts with "no", and ends with the unique\nname of the matcher (the one passed to the constructor). Using the example above, you can pass a\n',(0,l.kt)("inlineCode",{parentName:"p"},"noFoo")," prop."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx"},"<Interweave noFoo />\n")),(0,l.kt)("h2",{id:"creating-a-matcher"},"Creating a matcher"),(0,l.kt)("p",null,"To create a custom matcher, implement a class that extends the base ",(0,l.kt)("inlineCode",{parentName:"p"},"Matcher")," class, or use a plain\nobject. Both approaches will require the following methods to be defined (excluding callbacks)."),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"match(string: string)")," - Match the passed string using a regex pattern. This method must return\n",(0,l.kt)("inlineCode",{parentName:"li"},"null")," if no match is found (will abort matching), else it must return an object with the\nproperties below. Any additional keys defined in this object will be passed as props to the\nrendered element.",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"index")," (",(0,l.kt)("inlineCode",{parentName:"li"},"number"),") - The starting index in which the match was found (is provided by the native\n",(0,l.kt)("inlineCode",{parentName:"li"},"String#match()"),")."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"length")," (",(0,l.kt)("inlineCode",{parentName:"li"},"number"),") - The original length of the match, before it was potentially modified."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"match")," (",(0,l.kt)("inlineCode",{parentName:"li"},"string"),") - The content that was matched (is usually the 0-index in the result)."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"valid")," (",(0,l.kt)("inlineCode",{parentName:"li"},"boolean"),") - Whether the match is valid or not. This can be used to control false\npositives."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"void")," (",(0,l.kt)("inlineCode",{parentName:"li"},"boolean"),") - Mark the result as a void element. Cannot be nested by other matchers, nor\ncontain children (is self closing)."))),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"replaceWith(children: ChildrenNode, props: object)")," - Returns a React element that replaces the\nmatched content in the string. The parsed children are passed as the 1st argument, and any matched\nprops or parent props are passed as the 2nd argument."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"createElement(children: ChildrenNode, props: object)")," - The same as ",(0,l.kt)("inlineCode",{parentName:"li"},"replaceWith")," but used in\nobject matchers."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"asTag()")," - The HTML tag name of the replacement element."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"onBeforeParse(content: string, props: object)")," - Callback that fires before parsing. Is passed\nthe source string and must return a string."),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("inlineCode",{parentName:"li"},"onAfterParse(nodes: Node[], props: object)")," - Callback that fires after parsing. Is passed an\narray of strings/elements and must return an array.")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Using the plain object approach requires more implementation and a higher overhead.")),(0,l.kt)(o.Z,{groupId:"matcher-type",defaultValue:"class",values:[{label:"Class",value:"class"},{label:"Object",value:"object"}],mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"class",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Matcher, MatchResponse, Node } from 'interweave';\n\nclass CustomMatcher extends Matcher<CustomProps> {\n    match(string: string): MatchResponse<{ extraProp: string }> | null {\n        const result = string.match(/foo/);\n\n        if (!result) {\n            return null;\n        }\n\n        return {\n            index: result.index!,\n            length: result[0].length,\n            match: result[0],\n            extraProp: 'foo', // or result[1], etc\n            valid: true,\n        };\n    }\n\n    replaceWith(children: ChildrenNode, props: CustomProps): Node {\n        return <span {...props}>{children}</span>;\n    }\n\n    asTag(): string {\n        return 'span';\n    }\n}\n\nconst matcher = new CustomMatcher('foo');\n"))),(0,l.kt)(i.Z,{value:"object",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx"},"import { MatcherInterface } from 'interweave';\n\nconst matcher: MatcherInterface<CustomProps> = {\n    inverseName: 'noFoo',\n    propName: 'foo',\n    match(string) {\n        const result = string.match(/foo/);\n\n        if (!result) {\n            return null;\n        }\n\n        return {\n            index: result.index!,\n            length: result[0].length,\n            match: result[0],\n            extraProp: 'foo', // or result[1], etc\n            valid: true,\n        };\n    },\n    createElement(children, props) {\n        return <span {...props}>{children}</span>;\n    },\n    asTag() {\n        return 'span';\n    },\n};\n")))),(0,l.kt)("p",null,"To ease the matching process, there is a ",(0,l.kt)("inlineCode",{parentName:"p"},"doMatch()")," method on ",(0,l.kt)("inlineCode",{parentName:"p"},"Matcher")," that handles the ",(0,l.kt)("inlineCode",{parentName:"p"},"null")," and\nobject building logic. Simply pass it a regex pattern and a callback to build the object."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"class CustomMatcher extends Matcher<CustomProps> {\n    // ...\n\n    match(string: string): MatchResponse<{ extraProp: string }> | null {\n        return this.doMatch(string, /foo/, (matches) => ({\n            extraProp: 'foo',\n        }));\n    }\n}\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"When the matcher finds a match, the parser will temporarily wrap the match in a token that looks\nlike the following: ",(0,l.kt)("inlineCode",{parentName:"p"},"{{{foo1}}}matched content{{{/foo1}}}"),". This token ",(0,l.kt)("em",{parentName:"p"},"is present")," for subsequent\nmatchers, so be weary of the patterns you're attempting to match, as they may capture the\ntemporary tokens.")),(0,l.kt)("h2",{id:"rendered-elements"},"Rendered elements"),(0,l.kt)("p",null,"When a match is found, a React element is rendered (from a React component) from either the\nmatcher's ",(0,l.kt)("inlineCode",{parentName:"p"},"replaceWith()")," method, or from a factory. What's a factory you ask? Simply put, it's a\ncomponent reference passed to the constructor of a matcher, allowing the rendered element to be\ncustomized for built-in or third-party matchers."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-ts"},"new CustomMatcher('foo', {}, SomeComponent);\n")),(0,l.kt)("blockquote",null,(0,l.kt)("p",{parentName:"blockquote"},"Elements returned from ",(0,l.kt)("inlineCode",{parentName:"p"},"replaceWith()")," or the factory must return an HTML element with the same\ntag name as defined by ",(0,l.kt)("inlineCode",{parentName:"p"},"asTag()"),".")),(0,l.kt)("h2",{id:"greedy-matching"},"Greedy matching"),(0,l.kt)("p",null,"By default, a matcher will continually run until it exhausts all matches. However, each iteration\nwill shorten the string being matched until there is no more. This may be problematic if your\nmatcher uses multiple patterns, as they can happen in any order, or can be found at any point in the\nstring."),(0,l.kt)("p",null,"To work around this, a matcher can be marked as greedy to continually run against the whole string\neach iteration, until fully exhausted. Set the ",(0,l.kt)("inlineCode",{parentName:"p"},"greedy")," property to enable."),(0,l.kt)(o.Z,{groupId:"matcher-type",defaultValue:"class",values:[{label:"Class",value:"class"},{label:"Object",value:"object"}],mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"class",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx"},"import { Matcher } from 'interweave';\n\nclass CustomMatcher extends Matcher<CustomProps> {\n    greedy: boolean = true;\n\n    // ...\n}\n"))),(0,l.kt)(i.Z,{value:"object",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-tsx"},"import { MatcherInterface } from 'interweave';\n\nconst matcher: MatcherInterface<CustomProps> = {\n    greedy: true,\n\n    // ...\n};\n")))))}f.isMDXComponent=!0}}]);